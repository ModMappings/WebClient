/**
 * ModMappings API
 * This is the api for ModMappings. It is currently in development and in an alpha stage.
 *
 * The version of the OpenAPI document: 0.0.0-Dev
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

import { DetailedMapping } from '../model/models';
import { MappableType } from '../model/models';
import { Mapping } from '../model/models';
import { PageDetailedMapping } from '../model/models';
import { PageMapping } from '../model/models';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


export interface CreateMappingRequestParams {
    versionedMappable: string;
    mappingType: string;
    mapping?: Mapping;
}

export interface GetDetailedMappingByIdRequestParams {
    /** The id of the mapping to look up. */
    id: string;
}

export interface GetDetailedMappingsBySearchCriteriaRequestParams {
    /** Indicates if only latest mappings for a given versioned mappable should be taken into account. Defaults to true if not supplied. */
    latestOnly?: boolean;
    /** The id of the versioned mappable to filter on. */
    versionedMappableId?: string;
    /** The id of the release to filter on. */
    releaseId?: string;
    /** The mappable type to filter on. */
    mappableType?: MappableType;
    /** The regular expression to match the input of the mapping against. */
    inputRegex?: string;
    /** The regular expression to match the output of the mapping against. */
    outputRegex?: string;
    /** The id of the mapping type to filter on. */
    mappingTypeId?: string;
    /** The id of the game version to filter on. */
    gameVersionId?: string;
    /** The id of the user who created a mapping to filter on. */
    createdBy?: string;
    /** The id of the class of which the targeted mappings versioned mappable resides in. */
    parentClassId?: string;
    /** The id of the method of which the targeted mappings versioned mappable resides in. */
    parentMethodId?: string;
    /** Zero-based page index (0..N) */
    page?: number;
    /** The size of the page to be returned */
    size?: number;
    /** Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
    sort?: Array<string>;
}

export interface GetMappingsByIdRequestParams {
    /** The id of the mapping to look up. */
    id: string;
}

export interface GetMappingsBySearchCriteriaRequestParams {
    /** Indicates if only latest mappings for a given versioned mappable should be taken into account. Defaults to true if not supplied. */
    latestOnly?: boolean;
    /** The id of the versioned mappable to filter on. */
    versionedMappableId?: string;
    /** The id of the release to filter on. */
    releaseId?: string;
    /** The mappable type to filter on. */
    mappableType?: MappableType;
    /** The regular expression to match the input of the mapping against. */
    inputRegex?: string;
    /** The regular expression to match the output of the mapping against. */
    outputRegex?: string;
    /** The id of the mapping type to filter on. */
    mappingTypeId?: string;
    /** The id of the game version to filter on. */
    gameVersionId?: string;
    /** The id of the user who created a mapping to filter on. */
    createdBy?: string;
    /** The id of the class of which the targeted mappings versioned mappable resides in. */
    parentClassId?: string;
    /** The id of the method of which the targeted mappings versioned mappable resides in. */
    parentMethodId?: string;
    /** Zero-based page index (0..N) */
    page?: number;
    /** The size of the page to be returned */
    size?: number;
    /** Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported. */
    sort?: Array<string>;
}


@Injectable({
  providedIn: 'root'
})
export class MappingsService {

    protected basePath = 'http://localhost:8080';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }



    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key,
                        (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Creates the mapping from the data in the request body.
     * This converts the data in the request body into a full mapping, and stores it in the database. The components of this mapping are populated from the latest available mappings in the given mapping type and game version. The name of the mapping can not already be in use. A user needs to be authorized to perform this request. A user needs to have the role \&#39;MAPPINGS_CREATE\&#39; to execute this action successfully.
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createMapping(requestParameters: CreateMappingRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<Mapping>;
    public createMapping(requestParameters: CreateMappingRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<Mapping>>;
    public createMapping(requestParameters: CreateMappingRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<Mapping>>;
    public createMapping(requestParameters: CreateMappingRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        const versionedMappable = requestParameters.versionedMappable;
        if (versionedMappable === null || versionedMappable === undefined) {
            throw new Error('Required parameter versionedMappable was null or undefined when calling createMapping.');
        }
        const mappingType = requestParameters.mappingType;
        if (mappingType === null || mappingType === undefined) {
            throw new Error('Required parameter mappingType was null or undefined when calling createMapping.');
        }
        const mapping = requestParameters.mapping;

        let headers = this.defaultHeaders;

        // authentication (ModMappings auth) required
        if (this.configuration.accessToken) {
            const accessToken = typeof this.configuration.accessToken === 'function'
                ? this.configuration.accessToken()
                : this.configuration.accessToken;
            headers = headers.set('Authorization', 'Bearer ' + accessToken);
        }

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.post<Mapping>(`${this.configuration.basePath}/mappings/${encodeURIComponent(String(mappingType))}/${encodeURIComponent(String(versionedMappable))}`,
            mapping,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Looks up a detailed mapping using a given id.
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDetailedMappingById(requestParameters: GetDetailedMappingByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<DetailedMapping>;
    public getDetailedMappingById(requestParameters: GetDetailedMappingByIdRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<DetailedMapping>>;
    public getDetailedMappingById(requestParameters: GetDetailedMappingByIdRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<DetailedMapping>>;
    public getDetailedMappingById(requestParameters: GetDetailedMappingByIdRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        const id = requestParameters.id;
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDetailedMappingById.');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<DetailedMapping>(`${this.configuration.basePath}/mappings/detailed/${encodeURIComponent(String(id))}`,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all known mappings, and their metadata, and finds the ones that match the given parameters.
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDetailedMappingsBySearchCriteria(requestParameters: GetDetailedMappingsBySearchCriteriaRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<PageDetailedMapping>;
    public getDetailedMappingsBySearchCriteria(requestParameters: GetDetailedMappingsBySearchCriteriaRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<PageDetailedMapping>>;
    public getDetailedMappingsBySearchCriteria(requestParameters: GetDetailedMappingsBySearchCriteriaRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<PageDetailedMapping>>;
    public getDetailedMappingsBySearchCriteria(requestParameters: GetDetailedMappingsBySearchCriteriaRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        const latestOnly = requestParameters.latestOnly;
        const versionedMappableId = requestParameters.versionedMappableId;
        const releaseId = requestParameters.releaseId;
        const mappableType = requestParameters.mappableType;
        const inputRegex = requestParameters.inputRegex;
        const outputRegex = requestParameters.outputRegex;
        const mappingTypeId = requestParameters.mappingTypeId;
        const gameVersionId = requestParameters.gameVersionId;
        const createdBy = requestParameters.createdBy;
        const parentClassId = requestParameters.parentClassId;
        const parentMethodId = requestParameters.parentMethodId;
        const page = requestParameters.page;
        const size = requestParameters.size;
        const sort = requestParameters.sort;

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (latestOnly !== undefined && latestOnly !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>latestOnly, 'latestOnly');
        }
        if (versionedMappableId !== undefined && versionedMappableId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>versionedMappableId, 'versionedMappableId');
        }
        if (releaseId !== undefined && releaseId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>releaseId, 'releaseId');
        }
        if (mappableType !== undefined && mappableType !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>mappableType, 'mappableType');
        }
        if (inputRegex !== undefined && inputRegex !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>inputRegex, 'inputRegex');
        }
        if (outputRegex !== undefined && outputRegex !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>outputRegex, 'outputRegex');
        }
        if (mappingTypeId !== undefined && mappingTypeId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>mappingTypeId, 'mappingTypeId');
        }
        if (gameVersionId !== undefined && gameVersionId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>gameVersionId, 'gameVersionId');
        }
        if (createdBy !== undefined && createdBy !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>createdBy, 'createdBy');
        }
        if (parentClassId !== undefined && parentClassId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>parentClassId, 'parentClassId');
        }
        if (parentMethodId !== undefined && parentMethodId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>parentMethodId, 'parentMethodId');
        }
        if (page !== undefined && page !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>page, 'page');
        }
        if (size !== undefined && size !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>size, 'size');
        }
        if (sort) {
            sort.forEach((element) => {
                queryParameters = this.addToHttpParams(queryParameters,
                  <any>element, 'sort');
            })
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<PageDetailedMapping>(`${this.configuration.basePath}/mappings/detailed`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Looks up a mapping using a given id.
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMappingsById(requestParameters: GetMappingsByIdRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<Mapping>;
    public getMappingsById(requestParameters: GetMappingsByIdRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<Mapping>>;
    public getMappingsById(requestParameters: GetMappingsByIdRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<Mapping>>;
    public getMappingsById(requestParameters: GetMappingsByIdRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        const id = requestParameters.id;
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getMappingsById.');
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<Mapping>(`${this.configuration.basePath}/mappings/${encodeURIComponent(String(id))}`,
            {
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all known mappings and finds the ones that match the given parameters.
     * @param requestParameters
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMappingsBySearchCriteria(requestParameters: GetMappingsBySearchCriteriaRequestParams, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<PageMapping>;
    public getMappingsBySearchCriteria(requestParameters: GetMappingsBySearchCriteriaRequestParams, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<PageMapping>>;
    public getMappingsBySearchCriteria(requestParameters: GetMappingsBySearchCriteriaRequestParams, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<PageMapping>>;
    public getMappingsBySearchCriteria(requestParameters: GetMappingsBySearchCriteriaRequestParams, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {
        const latestOnly = requestParameters.latestOnly;
        const versionedMappableId = requestParameters.versionedMappableId;
        const releaseId = requestParameters.releaseId;
        const mappableType = requestParameters.mappableType;
        const inputRegex = requestParameters.inputRegex;
        const outputRegex = requestParameters.outputRegex;
        const mappingTypeId = requestParameters.mappingTypeId;
        const gameVersionId = requestParameters.gameVersionId;
        const createdBy = requestParameters.createdBy;
        const parentClassId = requestParameters.parentClassId;
        const parentMethodId = requestParameters.parentMethodId;
        const page = requestParameters.page;
        const size = requestParameters.size;
        const sort = requestParameters.sort;

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (latestOnly !== undefined && latestOnly !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>latestOnly, 'latestOnly');
        }
        if (versionedMappableId !== undefined && versionedMappableId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>versionedMappableId, 'versionedMappableId');
        }
        if (releaseId !== undefined && releaseId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>releaseId, 'releaseId');
        }
        if (mappableType !== undefined && mappableType !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>mappableType, 'mappableType');
        }
        if (inputRegex !== undefined && inputRegex !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>inputRegex, 'inputRegex');
        }
        if (outputRegex !== undefined && outputRegex !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>outputRegex, 'outputRegex');
        }
        if (mappingTypeId !== undefined && mappingTypeId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>mappingTypeId, 'mappingTypeId');
        }
        if (gameVersionId !== undefined && gameVersionId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>gameVersionId, 'gameVersionId');
        }
        if (createdBy !== undefined && createdBy !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>createdBy, 'createdBy');
        }
        if (parentClassId !== undefined && parentClassId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>parentClassId, 'parentClassId');
        }
        if (parentMethodId !== undefined && parentMethodId !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>parentMethodId, 'parentMethodId');
        }
        if (page !== undefined && page !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>page, 'page');
        }
        if (size !== undefined && size !== null) {
          queryParameters = this.addToHttpParams(queryParameters,
            <any>size, 'size');
        }
        if (sort) {
            sort.forEach((element) => {
                queryParameters = this.addToHttpParams(queryParameters,
                  <any>element, 'sort');
            })
        }

        let headers = this.defaultHeaders;

        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (httpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        let responseType: 'text' | 'json' = 'json';
        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {
            responseType = 'text';
        }

        return this.httpClient.get<PageMapping>(`${this.configuration.basePath}/mappings`,
            {
                params: queryParameters,
                responseType: <any>responseType,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
